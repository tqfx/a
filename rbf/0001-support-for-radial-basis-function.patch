From 51bae2a9af9648b9e0d4bf4dddcb935bf5418373 Mon Sep 17 00:00:00 2001
From: tqfx <tqfx@tqfx.org>
Date: Sat, 24 Feb 2024 22:36:40 +0800
Subject: [PATCH] support for radial basis function


diff --git a/include/a/rbf.h b/include/a/rbf.h
new file mode 100644
index 0000000..4ba6dd3
--- /dev/null
+++ b/include/a/rbf.h
@@ -0,0 +1,85 @@
+/*!
+ @file rbf.h
+ @brief radial basis function
+*/
+
+#ifndef LIBA_RBF_H
+#define LIBA_RBF_H
+
+#include "a.h"
+
+/*!
+ @ingroup A
+ @addtogroup A_RBF radial basis function
+ @{
+*/
+
+typedef struct a_rbf a_rbf;
+
+#if defined(__cplusplus)
+namespace a
+{
+typedef struct a_rbf rbf;
+} /* namespace a */
+extern "C" {
+#endif /* __cplusplus */
+
+/*!
+ @brief calculate for radial basis function
+ @param[in] ctx points to an instance of radial basis function
+ @return radial basis function output
+*/
+A_EXTERN a_float const *a_rbf_iter(a_rbf const *ctx);
+
+/*!
+ @brief tuning for radial basis function
+ @param[in] ctx points to an instance of radial basis function
+ @param[in] out points to the desired output buffer
+*/
+A_EXTERN void a_rbf_tune(a_rbf const *ctx, a_float const *out);
+
+/*!
+ @brief zeroing for radial basis function
+ @param[in] ctx points to an instance of radial basis function
+*/
+A_EXTERN void a_rbf_zero(a_rbf const *ctx);
+
+#if defined(__cplusplus)
+} /* extern "C" */
+#endif /* __cplusplus */
+
+/*!
+ @brief instance structure for radial basis function
+*/
+struct a_rbf
+{
+    a_float *input_p; //!< points to input layer
+    a_size input_n; //!< number of input layer
+    a_float *center_p; //!< points to center array
+    a_size center_n; //!< number of center array
+    a_float *height_p; //!< points to height array
+    a_size height_n; //!< number of height array
+    a_float *hidden_p; //!< points to hidden layer
+    a_size hidden_n; //!< number of hidden layer
+    a_float *output_p; //!< points to output layer
+    a_size output_n; //!< number of output layer
+    a_float *weight; //!< points to output weight
+    a_float *deltaw; //!< points to delta weight
+    a_float learn; //!< learning rate
+    a_float alpha; //!< momentum factor
+#if defined(__cplusplus)
+    A_INLINE a_float const *operator()()
+    {
+        return a_rbf_iter(this);
+    }
+    A_INLINE void tune(a_float const *out)
+    {
+        a_rbf_tune(this, out);
+    }
+    A_INLINE void zero() { a_rbf_zero(this); }
+#endif /* __cplusplus */
+};
+
+/*! @} A_RBF */
+
+#endif /* a/rbf.h */
diff --git a/meson.build b/meson.build
index 398b478..82111dd 100644
--- a/meson.build
+++ b/meson.build
@@ -64,6 +64,7 @@ sources = [
     'include/a/pid_neuro.h',
     'include/a/poly.h',
     'include/a/que.h',
+    'include/a/rbf.h',
     'include/a/rbt.h',
     'include/a/slist.h',
     'include/a/str.h',
@@ -89,6 +90,7 @@ sources = [
     'src/pid_neuro.c',
     'src/poly.c',
     'src/que.c',
+    'src/rbf.c',
     'src/rbt.c',
     'src/str.c',
     'src/tf.c',
diff --git a/src/rbf.c b/src/rbf.c
new file mode 100644
index 0000000..4f3c7e2
--- /dev/null
+++ b/src/rbf.c
@@ -0,0 +1,81 @@
+#include "a/rbf.h"
+#include "a/math.h"
+
+a_float const *a_rbf_iter(a_rbf const *ctx)
+{
+    a_size const input_hidden_n = ctx->input_n * ctx->hidden_n;
+    for (a_size hidden_i = 0; hidden_i != ctx->hidden_n; ++hidden_i)
+    {
+        a_float num = 0;
+        if (ctx->center_n == input_hidden_n)
+        {
+            a_float const *center_p = ctx->center_p + hidden_i;
+            for (a_size input_i = 0; input_i != ctx->input_n; ++input_i, center_p += ctx->input_n)
+            {
+                a_float const r = ctx->input_p[input_i] - *center_p;
+                num += r * r;
+            }
+        }
+        else if (ctx->center_n == ctx->hidden_n)
+        {
+            for (a_size input_i = 0; input_i != ctx->input_n; ++input_i)
+            {
+                a_float const r = ctx->input_p[input_i] - ctx->center_p[hidden_i];
+                num += r * r;
+            }
+        }
+        else if (ctx->center_n == 1)
+        {
+            for (a_size input_i = 0; input_i != ctx->input_n; ++input_i)
+            {
+                a_float const r = ctx->input_p[input_i] - *ctx->center_p;
+                num += r * r;
+            }
+        }
+        a_float den = 1;
+        if (ctx->height_n == ctx->hidden_n)
+        {
+            den = ctx->height_p[hidden_i] * ctx->height_p[hidden_i];
+        }
+        else if (ctx->height_n == 1)
+        {
+            den = *ctx->height_p * *ctx->height_p;
+        }
+        ctx->hidden_p[hidden_i] = a_float_exp(-num / den);
+    }
+    a_float const *weight_p = ctx->weight;
+    for (a_size output_i = 0; output_i != ctx->output_n; ++output_i)
+    {
+        ctx->output_p[output_i] = 0;
+        for (a_size hidden = 0; hidden != ctx->hidden_n; ++hidden)
+        {
+            ctx->output_p[output_i] += *weight_p++ * ctx->hidden_p[hidden];
+        }
+    }
+    return ctx->output_p;
+}
+
+void a_rbf_tune(a_rbf const *ctx, a_float const *out)
+{
+    a_float *weight = ctx->weight;
+    a_float *deltaw = ctx->deltaw;
+    for (a_size output_i = 0; output_i != ctx->output_n; ++output_i)
+    {
+        a_float error = out[output_i] - ctx->output_p[output_i];
+        for (a_size hidden_i = 0; hidden_i != ctx->hidden_n; ++hidden_i)
+        {
+            *deltaw = ctx->learn * error * ctx->hidden_p[hidden_i] + ctx->alpha * *deltaw;
+            *weight++ += *deltaw++;
+        }
+    }
+}
+
+void a_rbf_zero(a_rbf const *ctx)
+{
+    a_size const hidden_output_n = ctx->hidden_n * ctx->output_n;
+    a_zero(ctx->input_p, sizeof(a_float) * ctx->input_n);
+    a_zero(ctx->hidden_p, sizeof(a_float) * ctx->hidden_n);
+    a_zero(ctx->output_p, sizeof(a_float) * ctx->output_n);
+    a_zero(ctx->weight, sizeof(a_float) * hidden_output_n);
+    a_zero(ctx->deltaw, sizeof(a_float) * hidden_output_n);
+}
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index fac96b4..4e305b7 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -250,6 +250,13 @@ unittest(poly)
 building(que que.c que.cc)
 unittest(que)
 
+building(rbf rbf.c rbf.cc)
+unittest(rbf)
+
+if(LIBA_GNUPLOT AND GNUPLOT_FOUND)
+  unitplot(rbf 3.gp rbf.csv)
+endif()
+
 building(rbt rbt.c rbt.cc)
 unittest(rbt)
 
diff --git a/test/make.lua b/test/make.lua
index 3ec6deb..4f99e24 100644
--- a/test/make.lua
+++ b/test/make.lua
@@ -32,6 +32,7 @@ executable("pid_fuzzy")
 executable("pid_neuro")
 executable("poly")
 executable("que")
+executable("rbf")
 executable("rbt")
 executable("slist")
 executable("str")
diff --git a/test/rbf.c b/test/rbf.c
new file mode 100644
index 0000000..988fa26
--- /dev/null
+++ b/test/rbf.c
@@ -0,0 +1 @@
+#include "rbf.h"
diff --git a/test/rbf.cc b/test/rbf.cc
new file mode 100644
index 0000000..988fa26
--- /dev/null
+++ b/test/rbf.cc
@@ -0,0 +1 @@
+#include "rbf.h"
diff --git a/test/rbf.h b/test/rbf.h
new file mode 100644
index 0000000..88b804d
--- /dev/null
+++ b/test/rbf.h
@@ -0,0 +1,56 @@
+#define MAIN(x) rbf##x
+#include "test.h"
+#include "a/tf.h"
+#include "a/rbf.h"
+#include "a/math.h"
+
+int main(int argc, char *argv[]) // NOLINT(misc-definitions-in-headers)
+{
+    main_init(argc, argv, 1);
+
+    a_tf tf;
+    {
+        static a_float num[] = {A_FLOAT_C(6.59492796e-05), A_FLOAT_C(6.54019884e-05)};
+        static a_float den[] = {A_FLOAT_C(-1.97530991), A_FLOAT_C(0.97530991)};
+        static a_float input[A_LEN(num)];
+        static a_float output[A_LEN(den)];
+        a_tf_init(&tf, A_LEN(num), num, input, A_LEN(den), den, output);
+    }
+    a_rbf ctx;
+    {
+        static a_float input[2];
+        static a_float center[10] = {-1, A_FLOAT_C(-0.5), 0, A_FLOAT_C(0.5), 1, -10, 5, 0, 5, 10};
+        static a_float height[5] = {A_FLOAT_C(1.5), A_FLOAT_C(1.5), A_FLOAT_C(1.5), A_FLOAT_C(1.5), A_FLOAT_C(1.5)};
+        static a_float hidden[5];
+        static a_float weight[5];
+        static a_float deltaw[5];
+        static a_float output[1];
+        ctx.input_p = input;
+        ctx.input_n = 2;
+        ctx.center_p = center;
+        ctx.center_n = 10;
+        ctx.height_p = height;
+        ctx.height_n = 1;
+        ctx.hidden_p = hidden;
+        ctx.hidden_n = 5;
+        ctx.output_p = output;
+        ctx.output_n = 1;
+        ctx.weight = weight;
+        ctx.deltaw = deltaw;
+        ctx.learn = A_FLOAT_C(0.5);
+        ctx.alpha = A_FLOAT_C(0.05);
+        a_rbf_zero(&ctx);
+    }
+
+    for (unsigned int i = 0; i < 1000; ++i)
+    {
+        ctx.input_p[0] = a_float_sin(A_FLOAT_C(0.002) * A_FLOAT_PI * a_float_c(i));
+        ctx.input_p[1] = *tf.output;
+        a_rbf_tune(&ctx, ctx.input_p);
+        a_tf_iter(&tf, *a_rbf_iter(&ctx));
+        debug(A_FLOAT_PRI("+", "f,") A_FLOAT_PRI("+", "f,") A_FLOAT_PRI("+", "f,") A_FLOAT_PRI("+", "f\n"),
+              A_FLOAT_C(0.002) * A_FLOAT_PI * a_float_c(i), *ctx.input_p, *ctx.output_p, *tf.output);
+    }
+
+    return 0;
+}
diff --git a/test/test.lua b/test/test.lua
index ff0fc76..b77d8d2 100644
--- a/test/test.lua
+++ b/test/test.lua
@@ -19,6 +19,7 @@ assert(subprocess.spawn({ "build/bin/pid_fuzzy" .. ext })):wait()
 assert(subprocess.spawn({ "build/bin/pid_neuro" .. ext })):wait()
 assert(subprocess.spawn({ "build/bin/poly" .. ext })):wait()
 assert(subprocess.spawn({ "build/bin/que" .. ext })):wait()
+assert(subprocess.spawn({ "build/bin/rbf" .. ext })):wait()
 assert(subprocess.spawn({ "build/bin/rbt" .. ext })):wait()
 assert(subprocess.spawn({ "build/bin/slist" .. ext })):wait()
 assert(subprocess.spawn({ "build/bin/str" .. ext })):wait()
diff --git a/test/xmake.lua b/test/xmake.lua
index e87ddeb..848b115 100644
--- a/test/xmake.lua
+++ b/test/xmake.lua
@@ -88,6 +88,10 @@ target("test/que")
 building({ "que.c", "que.cc" })
 target_end()
 
+target("test/rbf")
+building({ "rbf.c", "rbf.cc" })
+target_end()
+
 target("test/rbt")
 building({ "rbt.c", "rbt.cc" })
 target_end()
-- 
2.44.0

